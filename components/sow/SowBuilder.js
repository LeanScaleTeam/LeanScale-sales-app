/**
 * SowBuilder - Main SOW builder orchestrating diagnostic item selection + section management
 *
 * PRICING MODEL: Retainer-based tiers (not rate Ã— hours)
 * Sections have editable hours (with catalog suggestion). Total hours â†’ tier â†’ monthly price.
 *
 * Two-panel layout:
 *   Left:  DiagnosticItemPicker (select items to include)
 *   Right: SectionEditor list (organize items into named bundles)
 */

import { useState, useMemo, useRef, useCallback } from 'react';
import DiagnosticItemPicker from './DiagnosticItemPicker';
import SectionEditor from './SectionEditor';
import SectionConfigurator from './SectionConfigurator';
import TierSelector from './TierSelector';
import TimelineConfigurator from './TimelineConfigurator';
import CatalogPicker from './CatalogPicker';
import ExecutiveSummaryEditor from './ExecutiveSummaryEditor';
import AssumptionsEditor from './AssumptionsEditor';
import { TIERS } from '../../lib/engagement-engine';

function recommendTier(totalHours) {
  return TIERS.find(t => totalHours / t.hours <= 6) || TIERS[TIERS.length - 1];
}

export default function SowBuilder({
  sow,
  sections: initialSections = [],
  diagnosticResult,
  onSave,
}) {
  const [sections, setSections] = useState(initialSections);
  const [executiveSummary, setExecutiveSummary] = useState(
    sow?.content?.executive_summary || ''
  );
  const [regenerating, setRegenerating] = useState(false);
  const [groupBy, setGroupBy] = useState('function');
  const [selectedItems, setSelectedItems] = useState(() => {
    const existingItems = new Set();
    initialSections.forEach(s => {
      (s.diagnostic_items || []).forEach(name => existingItems.add(name));
    });
    if (existingItems.size > 0) {
      return Array.from(existingItems);
    }
    const processes = diagnosticResult?.processes || [];
    return processes
      .filter(p => p.status === 'warning' || p.status === 'unable')
      .map(p => p.name);
  });
  const [saving, setSaving] = useState(false);
  const [error, setError] = useState(null);
  const [activeSection, setActiveSection] = useState(null);
  const [showCatalog, setShowCatalog] = useState(false);
  const [tierConfig, setTierConfig] = useState(
    sow?.content?.tier_config || {
      selectedTierId: null, // null = auto-recommend
      customTier: null,     // { hours, price, label } for non-standard deals
      paymentTerms: 'Net 30',
      currency: 'USD',
    }
  );
  const [velocity, setVelocity] = useState(sow?.content?.velocity || 40);
  const dragItem = useRef(null);
  const dragOverItem = useRef(null);

  const processes = diagnosticResult?.processes || [];

  const processMap = useMemo(() => {
    const map = {};
    processes.forEach(p => { map[p.name] = p; });
    return map;
  }, [processes]);

  const isAutoGenerated = useMemo(() => {
    return initialSections.some(s => s.diagnostic_items && s.diagnostic_items.length > 0);
  }, [initialSections]);

  // Save executive summary to API
  const saveExecutiveSummary = useCallback(async () => {
    try {
      await fetch(`/api/sow/${sow.id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          content: { ...sow.content, executive_summary: executiveSummary },
        }),
      });
    } catch (err) {
      setError('Failed to save executive summary.');
    }
  }, [sow.id, sow.content, executiveSummary]);

  // Save tier config to SOW content
  const saveTierConfig = useCallback(async (newConfig) => {
    setTierConfig(newConfig);
    try {
      await fetch(`/api/sow/${sow.id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          contentPartial: { tier_config: newConfig },
        }),
      });
    } catch (err) {
      setError('Failed to save tier configuration.');
    }
  }, [sow.id]);

  // Save velocity to SOW content
  async function handleVelocityChange(v) {
    setVelocity(v);
    try {
      await fetch(`/api/sow/${sow.id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ contentPartial: { velocity: v } }),
      });
    } catch (err) { /* silent */ }
  }

  // Regenerate sections from diagnostic
  async function handleRegenerate() {
    if (!confirm('This will replace auto-generated sections. Manually added sections will be preserved. Continue?')) {
      return;
    }
    setRegenerating(true);
    try {
      const diagnosticResultId = sow.diagnostic_result_ids?.[0];
      if (!diagnosticResultId) {
        setError('No diagnostic result linked to this SOW.');
        return;
      }
      const res = await fetch('/api/sow/auto-generate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          diagnosticResultId,
          sowId: sow.id,
          groupBy,
          preserveManual: true,
          customerId: sow.customer_id,
          customerName: sow.content?.client_info?.company,
        }),
      });
      const json = await res.json();
      if (json.success) {
        setSections(json.data.sections || []);
        if (json.data.content?.executive_summary) {
          setExecutiveSummary(json.data.content.executive_summary);
        }
      } else {
        setError(json.error || 'Failed to regenerate sections.');
      }
    } catch (err) {
      setError('Failed to regenerate sections. Please try again.');
    } finally {
      setRegenerating(false);
    }
  }

  async function handleGroupByChange(e) {
    setGroupBy(e.target.value);
    if (isAutoGenerated) {
      setTimeout(() => handleRegenerate(), 0);
    }
  }

  // Build a map of which items are assigned to which sections
  const assignedItems = useMemo(() => {
    const map = {};
    sections.forEach(s => {
      (s.diagnostic_items || []).forEach(name => {
        map[name] = s.title || 'Untitled Section';
      });
    });
    return map;
  }, [sections]);

  // --- Section CRUD ---

  async function addSection() {
    try {
      const res = await fetch(`/api/sow/${sow.id}/sections`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          title: `Section ${sections.length + 1}`,
          sortOrder: sections.length,
        }),
      });
      const json = await res.json();
      if (json.success) {
        setSections(prev => [...prev, json.data]);
        setActiveSection(json.data.id);
      }
    } catch (err) {
      setError('Failed to add section. Please try again.');
    }
  }

  async function addSectionFromCatalog(service) {
    setShowCatalog(false);
    try {
      const hours = service.hours_low && service.hours_high
        ? Math.round((service.hours_low + service.hours_high) / 2)
        : service.hours_low || null;

      const res = await fetch(`/api/sow/${sow.id}/sections`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          title: service.name,
          description: service.description || '',
          hours: hours,
          catalogHours: hours, // Store original suggestion
          deliverables: (service.key_steps || []).map(step =>
            typeof step === 'string' ? step : step.name || step.title || String(step)
          ),
          sortOrder: sections.length,
          service_catalog_id: service.id,
        }),
      });
      const json = await res.json();
      if (json.success) {
        setSections(prev => [...prev, json.data]);
        setActiveSection(json.data.id);
      }
    } catch (err) {
      setError('Failed to add section from catalog. Please try again.');
    }
  }

  async function updateSection(sectionId, updates) {
    try {
      const res = await fetch(`/api/sow/${sow.id}/sections/${sectionId}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updates),
      });
      const json = await res.json();
      if (json.success) {
        setSections(prev => prev.map(s => s.id === sectionId ? json.data : s));
      }
    } catch (err) {
      setError('Failed to update section. Please try again.');
    }
  }

  async function deleteSection(sectionId) {
    try {
      const res = await fetch(`/api/sow/${sow.id}/sections/${sectionId}`, {
        method: 'DELETE',
      });
      const json = await res.json();
      if (json.success) {
        setSections(prev => prev.filter(s => s.id !== sectionId));
      }
    } catch (err) {
      setError('Failed to delete section. Please try again.');
    }
  }

  // --- Assign selected items to active section ---

  function assignItemsToSection(sectionId) {
    const section = sections.find(s => s.id === sectionId);
    if (!section) return;

    const unassigned = selectedItems.filter(name => !assignedItems[name]);
    if (unassigned.length === 0) return;

    const updatedDiagnosticItems = [...(section.diagnostic_items || []), ...unassigned];
    updateSection(sectionId, { diagnosticItems: updatedDiagnosticItems });
  }

  function removeItemFromSection(sectionId, itemName) {
    const section = sections.find(s => s.id === sectionId);
    if (!section) return;

    const updatedDiagnosticItems = (section.diagnostic_items || []).filter(n => n !== itemName);
    updateSection(sectionId, { diagnosticItems: updatedDiagnosticItems });
  }

  // --- Drag and drop reordering ---

  function handleDragStart(index) { dragItem.current = index; }
  function handleDragEnter(index) { dragOverItem.current = index; }

  async function handleDragEnd() {
    if (dragItem.current === null || dragOverItem.current === null) return;
    if (dragItem.current === dragOverItem.current) {
      dragItem.current = null;
      dragOverItem.current = null;
      return;
    }

    const reordered = [...sections];
    const [dragged] = reordered.splice(dragItem.current, 1);
    reordered.splice(dragOverItem.current, 0, dragged);

    setSections(reordered);
    dragItem.current = null;
    dragOverItem.current = null;

    const ordering = reordered.map((s, i) => ({ id: s.id, sortOrder: i }));
    try {
      await fetch(`/api/sow/${sow.id}/sections`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ ordering }),
      });
    } catch (err) {
      setError('Failed to save section order. Please try again.');
    }
  }

  // --- Save all ---

  async function handleSaveAll() {
    setSaving(true);
    try {
      let minDate = null;
      let maxDate = null;

      sections.forEach(s => {
        if (s.start_date && (!minDate || s.start_date < minDate)) minDate = s.start_date;
        if (s.end_date && (!maxDate || s.end_date > maxDate)) maxDate = s.end_date;
      });

      // Retainer model: save total hours + tier info (not rate Ã— hours investment)
      await fetch(`/api/sow/${sow.id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          totalHours,
          totalInvestment: monthlyPrice * estimatedDuration,
          startDate: minDate,
          endDate: maxDate,
        }),
      });

      onSave?.();
    } catch (err) {
      setError('Failed to save SOW. Please try again.');
    } finally {
      setSaving(false);
    }
  }

  // Summary calculations â€” retainer model
  const totalHours = sections.reduce((sum, s) => sum + (parseFloat(s.hours) || 0), 0);
  const tier = tierConfig.customTier
    || (tierConfig.selectedTierId
      ? TIERS.find(t => t.id === tierConfig.selectedTierId)
      : null)
    || recommendTier(totalHours);
  const monthlyPrice = tier.price;
  const estimatedDuration = tier.hours > 0 ? Math.ceil(totalHours / tier.hours) : 0;
  const totalEngagementValue = monthlyPrice * estimatedDuration;
  const unassignedCount = selectedItems.filter(name => !assignedItems[name]).length;

  return (
    <div>
      {/* Error banner */}
      {error && (
        <div style={{
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          padding: 'var(--space-3) var(--space-5)',
          background: 'var(--status-warning-bg)',
          border: '1px solid var(--status-warning-bg)',
          borderRadius: 'var(--radius-xl)',
          marginBottom: 'var(--space-4)',
          color: 'var(--status-warning-text)',
          fontSize: 'var(--text-sm)',
        }}>
          <span>{error}</span>
          <button
            onClick={() => setError(null)}
            style={{
              background: 'none',
              border: 'none',
              color: 'var(--status-warning-text)',
              cursor: 'pointer',
              fontSize: 'var(--text-base)',
              padding: '0 0.25rem',
            }}
          >
            x
          </button>
        </div>
      )}

      {/* Auto-generated banner */}
      {isAutoGenerated && (
        <div style={{
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          padding: 'var(--space-3) var(--space-5)',
          background: 'var(--status-healthy-bg)',
          border: '1px solid var(--status-healthy-bg)',
          borderRadius: 'var(--radius-xl)',
          marginBottom: 'var(--space-4)',
          fontSize: 'var(--text-sm)',
          color: 'var(--status-healthy-text)',
        }}>
          <span>
            âœ¨ <strong>{sections.length} sections</strong> were auto-generated from your diagnostic results.
            Review and adjust hours as needed â€” the tier and pricing will update automatically.
          </span>
          <div style={{ display: 'flex', gap: 'var(--space-2)', alignItems: 'center' }}>
            <select
              value={groupBy}
              onChange={handleGroupByChange}
              style={{
                padding: '0.3rem 0.5rem',
                border: '1px solid var(--status-healthy-bg)',
                borderRadius: 'var(--radius-md)',
                fontSize: 'var(--text-xs)',
                background: 'var(--bg-white)',
                color: 'var(--status-healthy-text)',
              }}
            >
              <option value="function">Group by Function</option>
              <option value="outcome">Group by Outcome</option>
            </select>
            <button
              onClick={handleRegenerate}
              disabled={regenerating}
              style={{
                padding: 'var(--space-1) var(--space-3)',
                background: '#276749',
                color: 'white',
                border: 'none',
                borderRadius: 'var(--radius-md)',
                fontSize: 'var(--text-xs)',
                fontWeight: 'var(--font-medium)',
                cursor: regenerating ? 'wait' : 'pointer',
                opacity: regenerating ? 0.7 : 1,
              }}
            >
              {regenerating ? 'Regenerating...' : 'ðŸ”„ Regenerate'}
            </button>
          </div>
        </div>
      )}

      {/* Executive Summary Editor */}
      {(executiveSummary || isAutoGenerated) && (
        <ExecutiveSummaryEditor
          value={executiveSummary}
          onChange={setExecutiveSummary}
          sowId={sow.id}
          diagnosticResult={diagnosticResult}
          customerName={sow.content?.client_info?.company}
          templateVars={{
            customerName: sow.content?.client_info?.company,
            overallRating: sow.overall_rating,
            warningCount: processes.filter(p => p.status === 'warning').length,
            functionBreakdown: [...new Set(processes.map(p => p.function).filter(Boolean))].join(', '),
          }}
        />
      )}

      {/* Summary bar â€” retainer model */}
      <div style={{
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        padding: 'var(--space-4) var(--space-5)',
        background: 'var(--bg-subtle)',
        border: '1px solid var(--border-color)',
        borderRadius: 'var(--radius-xl)',
        marginBottom: 'var(--space-6)',
        flexWrap: 'wrap',
        gap: 'var(--space-3)',
      }}>
        <div style={{ display: 'flex', gap: 'var(--space-6)', fontSize: 'var(--text-sm)' }}>
          <SummaryItem label="Sections" value={sections.length} />
          <SummaryItem label="Total Hours" value={totalHours} />
          <SummaryItem label="Tier" value={tier.label} color="#6C5CE7" />
          <SummaryItem label="Monthly" value={`$${monthlyPrice.toLocaleString()}/mo`} color="#276749" />
          <SummaryItem label="Duration" value={`${estimatedDuration} mo`} />
          <SummaryItem label="Total Value" value={`$${totalEngagementValue.toLocaleString()}`} color="#276749" />
          {unassignedCount > 0 && (
            <SummaryItem label="Unassigned" value={unassignedCount} color="#E53E3E" />
          )}
        </div>
        <div style={{ display: 'flex', gap: 'var(--space-3)' }}>
          <button
            onClick={handleSaveAll}
            disabled={saving}
            style={{
              padding: 'var(--space-2) var(--space-5)',
              background: 'var(--ls-purple-light)',
              color: 'white',
              border: 'none',
              borderRadius: 'var(--radius-md)',
              fontSize: 'var(--text-sm)',
              fontWeight: 'var(--font-semibold)',
              cursor: saving ? 'wait' : 'pointer',
              opacity: saving ? 0.7 : 1,
            }}
          >
            {saving ? 'Saving...' : 'Save SOW'}
          </button>
        </div>
      </div>

      {/* Tier Selector â€” retainer-based pricing */}
      <TierSelector
        sections={sections}
        config={tierConfig}
        onConfigChange={saveTierConfig}
      />

      {/* Two-panel layout */}
      <div style={{
        display: 'grid',
        gridTemplateColumns: '1fr 1fr',
        gap: 'var(--space-6)',
        alignItems: 'start',
      }}>
        {/* Left panel: Diagnostic Item Picker */}
        <div>
          <div style={{
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center',
            marginBottom: 'var(--space-3)',
          }}>
            <h3 style={{ fontSize: 'var(--text-base)', fontWeight: 'var(--font-semibold)', color: 'var(--gray-900)', margin: 0 }}>
              Diagnostic Items
            </h3>
            {activeSection && unassignedCount > 0 && (
              <button
                onClick={() => assignItemsToSection(activeSection)}
                style={{
                  padding: 'var(--space-1) var(--space-3)',
                  background: 'var(--ls-purple-light)',
                  color: 'white',
                  border: 'none',
                  borderRadius: 'var(--radius-md)',
                  fontSize: 'var(--text-xs)',
                  fontWeight: 'var(--font-medium)',
                  cursor: 'pointer',
                }}
              >
                Add {unassignedCount} to Section
              </button>
            )}
          </div>
          <DiagnosticItemPicker
            processes={processes}
            selectedItems={selectedItems}
            onSelectionChange={setSelectedItems}
            assignedItems={assignedItems}
          />
        </div>

        {/* Right panel: Sections */}
        <div>
          <div style={{
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center',
            marginBottom: 'var(--space-3)',
          }}>
            <h3 style={{ fontSize: 'var(--text-base)', fontWeight: 'var(--font-semibold)', color: 'var(--gray-900)', margin: 0 }}>
              SOW Sections
            </h3>
            <div style={{ display: 'flex', gap: 'var(--space-2)' }}>
              <button
                onClick={() => setShowCatalog(true)}
                style={{
                  padding: 'var(--space-1) var(--space-3)',
                  background: 'var(--status-healthy)',
                  color: 'white',
                  border: 'none',
                  borderRadius: 'var(--radius-md)',
                  fontSize: 'var(--text-xs)',
                  fontWeight: 'var(--font-medium)',
                  cursor: 'pointer',
                }}
              >
                + From Catalog
              </button>
              <button
                onClick={addSection}
                style={{
                  padding: 'var(--space-1) var(--space-3)',
                  background: 'var(--ls-purple-light)',
                  color: 'white',
                  border: 'none',
                  borderRadius: 'var(--radius-md)',
                  fontSize: 'var(--text-xs)',
                  fontWeight: 'var(--font-medium)',
                  cursor: 'pointer',
                }}
              >
                + Blank Section
              </button>
            </div>
          </div>

          {sections.length === 0 ? (
            <div style={{
              padding: 'var(--space-12) var(--space-8)',
              textAlign: 'center',
              border: '2px dashed #E2E8F0',
              borderRadius: 'var(--radius-xl)',
              color: 'var(--text-muted)',
            }}>
              <p style={{ fontSize: 'var(--text-sm)', marginBottom: 'var(--space-3)' }}>
                No sections yet. Create sections to organize diagnostic items into SOW bundles.
              </p>
              <button
                onClick={addSection}
                style={{
                  padding: 'var(--space-2) var(--space-4)',
                  background: 'var(--ls-purple-light)',
                  color: 'white',
                  border: 'none',
                  borderRadius: 'var(--radius-md)',
                  fontSize: 'var(--text-sm)',
                  cursor: 'pointer',
                }}
              >
                Create First Section
              </button>
            </div>
          ) : (
            <div style={{ display: 'flex', flexDirection: 'column', gap: 'var(--space-4)' }}>
              {sections.map((section, index) => (
                <div
                  key={section.id}
                  draggable
                  onDragStart={() => handleDragStart(index)}
                  onDragEnter={() => handleDragEnter(index)}
                  onDragEnd={handleDragEnd}
                  onDragOver={(e) => e.preventDefault()}
                  onClick={() => setActiveSection(section.id)}
                  style={{
                    outline: activeSection === section.id ? '2px solid #6C5CE7' : 'none',
                    outlineOffset: '2px',
                    borderRadius: 'var(--radius-xl)',
                    cursor: 'grab',
                  }}
                >
                  <SectionConfigurator
                    section={section}
                    onUpdate={(updates) => updateSection(section.id, updates)}
                    onDelete={() => deleteSection(section.id)}
                    diagnosticItems={processMap}
                    velocity={velocity}
                  />
                </div>
              ))}
            </div>
          )}
        </div>
      </div>

      {/* Catalog picker modal */}
      {showCatalog && (
        <CatalogPicker
          onSelect={addSectionFromCatalog}
          onCancel={() => setShowCatalog(false)}
        />
      )}

      {/* Timeline Configurator */}
      <TimelineConfigurator
        sections={sections}
        onUpdateSection={(sectionId, updates) => updateSection(sectionId, updates)}
        velocity={velocity}
        onVelocityChange={handleVelocityChange}
      />

      {/* Assumptions & Acceptance Criteria Editor */}
      <AssumptionsEditor
        assumptions={sow?.content?.assumptions}
        acceptanceCriteria={sow?.content?.acceptance_criteria}
        sowId={sow.id}
      />
    </div>
  );
}

function SummaryItem({ label, value, color }) {
  return (
    <div>
      <div style={{ fontSize: 'var(--text-xs)', color: 'var(--text-muted)', textTransform: 'uppercase', letterSpacing: '0.05em' }}>
        {label}
      </div>
      <div style={{ fontWeight: 'var(--font-semibold)', color: color || '#1a1a2e' }}>
        {value}
      </div>
    </div>
  );
}
